#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ÊÆµÈöéÁöÑÁóÖÂ§âÊ§úÂá∫Â≠¶Áøí„Ç∑„Çπ„ÉÜ„É†
1. PAD-UFES-20„ÅßÂü∫Á§éÂ≠¶Áøí
2. „Éû„Çπ„ÇØÊ∏à„ÅøÁîªÂÉè„ÅßÁóÖÂ§âÊäΩÂá∫Â≠¶Áøí
3. ÂàùË¶ãÁîªÂÉè„Åß„ÅÆÁóÖÂ§âËá™ÂãïÊ§úÂá∫
"""

import os
import cv2
import json
import shutil
import numpy as np
from pathlib import Path
from ultralytics import YOLO
from datetime import datetime
from tqdm import tqdm
import yaml
import random

class ProgressiveLesionTrainer:
    def __init__(self, output_dir="progressive_lesion_training"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # PAD-UFES-20„ÇØ„É©„ÇπÂÆöÁæ©
        self.pad_classes = ['ACK', 'BCC', 'MEL', 'NEV', 'SCC', 'SEK']
        
        # ÁóÖÂ§â„Çø„Ç§„Éó„Éû„ÉÉ„Éî„É≥„Ç∞ÔºàÊó•Êú¨„ÅÆÁóÖÂ§âÂêç ‚Üí PAD-UFES-20„ÇØ„É©„ÇπÔºâ
        self.lesion_mapping = {
            'ADM': 'ACK',                    # ÂæåÂ§©ÊÄßÁúüÁöÆ„É°„É©„Éé„Çµ„Ç§„Éà„Éº„Ç∑„Çπ ‚Üí Actinic keratosis
            'Basal cell carcinoma': 'BCC',   # Âü∫Â∫ïÁ¥∞ËÉûÁôå
            'Malignant melanoma': 'MEL',     # ÊÇ™ÊÄßÈªíËâ≤ËÖ´ ‚Üí Melanoma
            'Nevus': 'NEV',                  # Ëâ≤Á¥†ÊÄßÊØçÊñë
            'Solar lentigo': 'SCC',          # Êó•ÂÖâÊÄßËâ≤Á¥†Êñë ‚Üí Squamous cell carcinoma
            'Seborrheic keratosis': 'SEK',   # ËÑÇÊºèÊÄßËßíÂåñÁóá
            'Ephelis': 'ACK',                # „Åù„Å∞„Åã„Åô ‚Üí Actinic keratosis
            'Melasma': 'ACK'                 # ËÇùÊñë ‚Üí Actinic keratosis
        }
        
        print(f"üéØ Progressive Lesion Trainer ÂàùÊúüÂåñ")
        print(f"üìÅ Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™: {self.output_dir}")
        print(f"üè• ÂØæË±°ÁóÖÂ§â„ÇØ„É©„Çπ: {', '.join(self.pad_classes)}")
    
    def stage1_create_foundation_dataset(self, source_dir, samples_per_class=15):
        """
        „Çπ„ÉÜ„Éº„Ç∏1: PAD-UFES-20„Çπ„Çø„Ç§„É´„ÅÆÂü∫Á§é„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàê
        ÂêÑÁóÖÂ§â„Çø„Ç§„Éó„Åã„ÇâÁîªÂÉè„ÇíÈÅ∏Êäû„Åó„ÄÅÂü∫Êú¨ÁöÑ„Å™ÁóÖÂ§âË™çË≠ò„ÇíÂ≠¶Áøí
        """
        print("\\nüèóÔ∏è  STAGE 1: PAD-UFES-20Âü∫Á§é„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàê")
        print("=" * 60)
        
        foundation_dir = self.output_dir / "stage1_foundation"
        yolo_dir = foundation_dir / "yolo_format"
        
        # „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†‰ΩúÊàê
        for split in ['train', 'val', 'test']:
            (yolo_dir / split / 'images').mkdir(parents=True, exist_ok=True)
            (yolo_dir / split / 'labels').mkdir(parents=True, exist_ok=True)
        
        source_path = Path(source_dir)
        all_data = []
        
        # ÂêÑÁóÖÂ§â„Çø„Ç§„Éó„Åã„ÇâÁîªÂÉè„ÇíÂèéÈõÜ
        for lesion_dir in source_path.iterdir():
            if not lesion_dir.is_dir():
                continue
                
            lesion_type = lesion_dir.name
            mapped_class = self.lesion_mapping.get(lesion_type, 'ACK')
            
            print(f"üìÇ ÂèéÈõÜ‰∏≠: {lesion_type} ‚Üí {mapped_class}")
            
            # ÂêÑ„Çø„Ç§„Éó„Åã„ÇâÊåáÂÆöÊï∞„ÅÆÁîªÂÉè„ÇíÂèñÂæó
            image_files = list(lesion_dir.glob("*.jpg"))
            selected_images = random.sample(image_files, min(samples_per_class, len(image_files)))
            
            for img_path in selected_images:
                all_data.append({
                    'path': img_path,
                    'class': mapped_class,
                    'original_type': lesion_type
                })
        
        print(f"üìä Á∑èÂèéÈõÜÁîªÂÉèÊï∞: {len(all_data)}")
        
        # „Éá„Éº„Çø„Ç∑„É£„ÉÉ„Éï„É´„Å®ÂàÜÂâ≤
        random.shuffle(all_data)
        total = len(all_data)
        train_end = int(total * 0.7)
        val_end = int(total * 0.9)
        
        splits = {
            'train': all_data[:train_end],
            'val': all_data[train_end:val_end],
            'test': all_data[val_end:]
        }
        
        processed_count = 0
        
        for split_name, data in splits.items():
            print(f"\\nüìã {split_name}„Éá„Éº„ÇøÂá¶ÁêÜ: {len(data)}‰ª∂")
            
            for i, item in enumerate(tqdm(data, desc=f"Stage1 {split_name}")):
                try:
                    # ÁîªÂÉèË™≠„ÅøËæº„Åø„Å®„É™„Çµ„Ç§„Ç∫
                    img = cv2.imread(str(item['path']))
                    if img is None:
                        continue
                    
                    img_resized = cv2.resize(img, (640, 640))
                    
                    # „Éï„Ç°„Ç§„É´Âêç‰ΩúÊàê
                    new_name = f"stage1_{split_name}_{i:04d}.jpg"
                    
                    # ÁîªÂÉè‰øùÂ≠ò
                    dst_img = yolo_dir / split_name / 'images' / new_name
                    cv2.imwrite(str(dst_img), img_resized)
                    
                    # YOLO„Ç¢„Éé„ÉÜ„Éº„Ç∑„Éß„É≥‰ΩúÊàêÔºàÁîªÂÉè‰∏≠Â§Æ„Å´ÁóÖÂ§â„Åå„ÅÇ„Çã„Å®‰ªÆÂÆöÔºâ
                    class_id = self.pad_classes.index(item['class'])
                    # ‰∏≠Â§Æ„ÅÆ70%„ÅÆÈ†òÂüü„Å´ÁóÖÂ§â„Åå„ÅÇ„Çã„Å®‰ªÆÂÆö
                    annotation = f"{class_id} 0.5 0.5 0.7 0.7"
                    
                    label_path = yolo_dir / split_name / 'labels' / f"stage1_{split_name}_{i:04d}.txt"
                    with open(label_path, 'w') as f:
                        f.write(annotation)
                    
                    processed_count += 1
                    
                except Exception as e:
                    print(f"‚ùå „Ç®„É©„Éº: {e}")
        
        # YAMLË®≠ÂÆö„Éï„Ç°„Ç§„É´‰ΩúÊàê
        yaml_config = {
            'path': str(yolo_dir.absolute()),
            'train': 'train/images',
            'val': 'val/images',
            'test': 'test/images',
            'nc': len(self.pad_classes),
            'names': self.pad_classes
        }
        
        yaml_path = yolo_dir / 'foundation_dataset.yaml'
        with open(yaml_path, 'w') as f:
            yaml.dump(yaml_config, f, default_flow_style=False)
        
        print(f"\\n‚úÖ Stage 1ÂÆå‰∫Ü: {processed_count}‰ª∂„ÅÆ„Éá„Éº„Çø„Çí‰ΩúÊàê")
        print(f"üìÑ Ë®≠ÂÆö„Éï„Ç°„Ç§„É´: {yaml_path}")
        
        return yaml_path, processed_count
    
    def stage1_train_foundation_model(self, yaml_path, epochs=30):
        """
        „Çπ„ÉÜ„Éº„Ç∏1: Âü∫Á§é„É¢„Éá„É´Ë®ìÁ∑¥
        """
        print("\\nüöÄ STAGE 1: Âü∫Á§é„É¢„Éá„É´Ë®ìÁ∑¥ÈñãÂßã")
        print("=" * 60)
        
        # YOLOv8n„Åã„ÇâÈñãÂßã
        model = YOLO('yolov8n.pt')
        
        # Âü∫Á§éË®ìÁ∑¥ÂÆüË°å
        results = model.train(
            data=yaml_path,
            epochs=epochs,
            imgsz=640,
            batch=16,
            name=f'stage1_foundation_{datetime.now().strftime("%Y%m%d_%H%M%S")}',
            patience=10,
            save=True,
            cache=True,
            device='mps',
            workers=4,
            project=self.output_dir / 'training_runs',
            
            # Âü∫Á§éÂ≠¶Áøí„ÅÆË®≠ÂÆö
            lr0=0.01,      # Ê®ôÊ∫ñÁöÑ„Å™Â≠¶ÁøíÁéá
            lrf=0.01,
            warmup_epochs=5,
            
            # „Éá„Éº„ÇøÊã°ÂºµË®≠ÂÆö
            degrees=15.0,   # ÂõûËª¢
            translate=0.1,  # Âπ≥Ë°åÁßªÂãï
            scale=0.5,      # „Çπ„Ç±„Éº„É´Â§âÊõ¥
            fliplr=0.5,     # Â∑¶Âè≥ÂèçËª¢
            mixup=0.1,      # „Éü„ÉÉ„ÇØ„Çπ„Ç¢„ÉÉ„Éó
            
            # ÊúÄÈÅ©ÂåñË®≠ÂÆö
            optimizer='AdamW',
            close_mosaic=10
        )
        
        foundation_model_path = results.save_dir / 'weights' / 'best.pt'
        print(f"\\n‚úÖ Stage 1Ë®ìÁ∑¥ÂÆå‰∫Ü!")
        print(f"üèÜ Âü∫Á§é„É¢„Éá„É´: {foundation_model_path}")
        
        return foundation_model_path, results
    
    def stage2_create_masked_lesion_dataset(self, source_dir, foundation_model_path, samples_per_class=10):
        """
        „Çπ„ÉÜ„Éº„Ç∏2: „Éû„Çπ„ÇØÊ∏à„ÅøÁîªÂÉè„Åã„ÇâÁóÖÂ§âÈÉ®„ÇíÊäΩÂá∫„Åó„Å¶„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàê
        """
        print("\\nüé≠ STAGE 2: „Éû„Çπ„ÇØÊ∏à„ÅøÁóÖÂ§âÊäΩÂá∫„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàê")
        print("=" * 60)
        
        stage2_dir = self.output_dir / "stage2_masked_lesions"
        yolo_dir = stage2_dir / "yolo_format"
        
        # „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†‰ΩúÊàê
        for split in ['train', 'val']:
            (yolo_dir / split / 'images').mkdir(parents=True, exist_ok=True)
            (yolo_dir / split / 'labels').mkdir(parents=True, exist_ok=True)
        
        # Âü∫Á§é„É¢„Éá„É´„É≠„Éº„Éâ
        foundation_model = YOLO(foundation_model_path)
        
        source_path = Path(source_dir)
        extracted_lesions = []
        
        # ÂêÑÁóÖÂ§â„Çø„Ç§„Éó„Åã„ÇâÁîªÂÉè„ÇíÂá¶ÁêÜ
        for lesion_dir in source_path.iterdir():
            if not lesion_dir.is_dir():
                continue
                
            lesion_type = lesion_dir.name
            mapped_class = self.lesion_mapping.get(lesion_type, 'ACK')
            
            print(f"\\nüîç ÁóÖÂ§âÊäΩÂá∫‰∏≠: {lesion_type} ‚Üí {mapped_class}")
            
            # ÂêÑ„Çø„Ç§„Éó„Åã„ÇâÊåáÂÆöÊï∞„ÅÆÁîªÂÉè„ÇíÂá¶ÁêÜ
            image_files = list(lesion_dir.glob("*.jpg"))
            selected_images = random.sample(image_files, min(samples_per_class, len(image_files)))
            
            for img_path in tqdm(selected_images, desc=f"Extracting {lesion_type}"):
                try:
                    # Âü∫Á§é„É¢„Éá„É´„ÅßÁóÖÂ§âÊ§úÂá∫
                    results = foundation_model(str(img_path), conf=0.3, verbose=False)
                    
                    img = cv2.imread(str(img_path))
                    if img is None:
                        continue
                    
                    # Ê§úÂá∫„Åï„Çå„ÅüÁóÖÂ§â„Åã„ÇâÈ´ò‰ø°È†ºÂ∫¶„ÅÆ„ÇÇ„ÅÆ„ÇíÊäΩÂá∫
                    for result in results:
                        if result.boxes is not None:
                            for box in result.boxes:
                                conf = float(box.conf[0])
                                if conf > 0.4:  # È´ò‰ø°È†ºÂ∫¶„ÅÆ„Åø
                                    x1, y1, x2, y2 = map(int, box.xyxy[0])
                                    
                                    # ÁóÖÂ§âROIÊäΩÂá∫
                                    lesion_roi = img[y1:y2, x1:x2]
                                    if lesion_roi.size == 0:
                                        continue
                                    
                                    # 640x640„Å´„É™„Çµ„Ç§„Ç∫
                                    lesion_resized = cv2.resize(lesion_roi, (640, 640))
                                    
                                    extracted_lesions.append({
                                        'image': lesion_resized,
                                        'class': mapped_class,
                                        'confidence': conf,
                                        'original_type': lesion_type
                                    })
                
                except Exception as e:
                    print(f"‚ùå „Ç®„É©„Éº {img_path}: {e}")
        
        print(f"\\nüìä ÊäΩÂá∫„Åï„Çå„ÅüÁóÖÂ§âÊï∞: {len(extracted_lesions)}")
        
        if len(extracted_lesions) == 0:
            print("‚ùå ÁóÖÂ§â„ÅåÊäΩÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü")
            return None, 0
        
        # „Éá„Éº„Çø„Çítrain/val„Å´ÂàÜÂâ≤
        random.shuffle(extracted_lesions)
        train_count = int(len(extracted_lesions) * 0.8)
        
        splits = {
            'train': extracted_lesions[:train_count],
            'val': extracted_lesions[train_count:]
        }
        
        processed_count = 0
        
        for split_name, data in splits.items():
            print(f"\\nüìã {split_name}„Éá„Éº„ÇøÂá¶ÁêÜ: {len(data)}‰ª∂")
            
            for i, item in enumerate(tqdm(data, desc=f"Stage2 {split_name}")):
                try:
                    # ÁîªÂÉè‰øùÂ≠ò
                    img_name = f"stage2_{split_name}_{i:04d}.jpg"
                    img_path = yolo_dir / split_name / 'images' / img_name
                    cv2.imwrite(str(img_path), item['image'])
                    
                    # YOLO„Ç¢„Éé„ÉÜ„Éº„Ç∑„Éß„É≥ÔºàÊäΩÂá∫„Åï„Çå„ÅüÁóÖÂ§â„Å™„ÅÆ„ÅßÂÖ®‰Ωì„ÅåÁóÖÂ§âÔºâ
                    class_id = self.pad_classes.index(item['class'])
                    annotation = f"{class_id} 0.5 0.5 0.9 0.9"  # 90%„ÅåÁóÖÂ§â
                    
                    label_path = yolo_dir / split_name / 'labels' / f"stage2_{split_name}_{i:04d}.txt"
                    with open(label_path, 'w') as f:
                        f.write(annotation)
                    
                    processed_count += 1
                    
                except Exception as e:
                    print(f"‚ùå „Ç®„É©„Éº: {e}")
        
        # YAMLË®≠ÂÆö„Éï„Ç°„Ç§„É´‰ΩúÊàê
        yaml_config = {
            'path': str(yolo_dir.absolute()),
            'train': 'train/images',
            'val': 'val/images',
            'nc': len(self.pad_classes),
            'names': self.pad_classes
        }
        
        yaml_path = yolo_dir / 'masked_lesion_dataset.yaml'
        with open(yaml_path, 'w') as f:
            yaml.dump(yaml_config, f, default_flow_style=False)
        
        print(f"\\n‚úÖ Stage 2ÂÆå‰∫Ü: {processed_count}‰ª∂„ÅÆÁóÖÂ§â„Éá„Éº„Çø„Çí‰ΩúÊàê")
        print(f"üìÑ Ë®≠ÂÆö„Éï„Ç°„Ç§„É´: {yaml_path}")
        
        return yaml_path, processed_count
    
    def stage2_enhance_model(self, foundation_model_path, stage2_yaml_path, epochs=20):
        """
        „Çπ„ÉÜ„Éº„Ç∏2: Âü∫Á§é„É¢„Éá„É´„ÇíÁóÖÂ§âÊäΩÂá∫„Éá„Éº„Çø„ÅßÂº∑Âåñ
        """
        print("\\nüî• STAGE 2: „É¢„Éá„É´Âº∑ÂåñË®ìÁ∑¥ÈñãÂßã")
        print("=" * 60)
        
        # Âü∫Á§é„É¢„Éá„É´„É≠„Éº„Éâ
        model = YOLO(foundation_model_path)
        
        # Âº∑ÂåñË®ìÁ∑¥ÂÆüË°å
        results = model.train(
            data=stage2_yaml_path,
            epochs=epochs,
            imgsz=640,
            batch=8,
            name=f'stage2_enhanced_{datetime.now().strftime("%Y%m%d_%H%M%S")}',
            patience=8,
            save=True,
            cache=True,
            device='mps',
            workers=2,
            project=self.output_dir / 'training_runs',
            
            # „Éï„Ç°„Ç§„É≥„ÉÅ„É•„Éº„Éã„É≥„Ç∞Ë®≠ÂÆö
            lr0=0.001,     # ‰Ωé„ÅÑÂ≠¶ÁøíÁéá„Åß„Éï„Ç°„Ç§„É≥„ÉÅ„É•„Éº„Éã„É≥„Ç∞
            lrf=0.0001,
            warmup_epochs=3,
            
            # ËªΩÂ∫¶„Å™„Éá„Éº„ÇøÊã°Âºµ
            degrees=10.0,
            translate=0.05,
            scale=0.2,
            fliplr=0.5,
            mixup=0.05,
            
            # ÊúÄÈÅ©ÂåñË®≠ÂÆö
            optimizer='AdamW',
            close_mosaic=8
        )
        
        enhanced_model_path = results.save_dir / 'weights' / 'best.pt'
        print(f"\\n‚úÖ Stage 2Âº∑ÂåñÂÆå‰∫Ü!")
        print(f"üèÜ Âº∑Âåñ„É¢„Éá„É´: {enhanced_model_path}")
        
        return enhanced_model_path, results
    
    def stage3_test_on_unseen_images(self, enhanced_model_path, test_images_dir):
        """
        „Çπ„ÉÜ„Éº„Ç∏3: ÂàùË¶ãÁîªÂÉè„Åß„ÅÆÁóÖÂ§âÊ§úÂá∫„ÉÜ„Çπ„Éà
        """
        print("\\nüß™ STAGE 3: ÂàùË¶ãÁîªÂÉè„Åß„ÅÆÁóÖÂ§âÊ§úÂá∫„ÉÜ„Çπ„Éà")
        print("=" * 60)
        
        model = YOLO(enhanced_model_path)
        test_results = []
        
        test_path = Path(test_images_dir)
        output_dir = self.output_dir / "stage3_test_results"
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # ÂêÑÁóÖÂ§â„Çø„Ç§„Éó„Åã„ÇâÊï∞Êûö„Åö„Å§„ÉÜ„Çπ„Éà
        for lesion_dir in test_path.iterdir():
            if not lesion_dir.is_dir():
                continue
                
            lesion_type = lesion_dir.name
            expected_class = self.lesion_mapping.get(lesion_type, 'ACK')
            
            print(f"\\nüîç „ÉÜ„Çπ„Éà‰∏≠: {lesion_type} (ÊúüÂæÖ„ÇØ„É©„Çπ: {expected_class})")
            
            # ÂêÑ„Çø„Ç§„Éó„Åã„Çâ3Êûö„Çí„ÉÜ„Çπ„Éà
            image_files = list(lesion_dir.glob("*.jpg"))[:3]
            
            for img_path in image_files:
                try:
                    # Êé®Ë´ñÂÆüË°å
                    results = model(str(img_path), conf=0.25, save=True, save_dir=output_dir)
                    
                    detections = []
                    for result in results:
                        if result.boxes is not None:
                            for box in result.boxes:
                                cls_id = int(box.cls[0])
                                conf = float(box.conf[0])
                                predicted_class = self.pad_classes[cls_id]
                                x1, y1, x2, y2 = map(int, box.xyxy[0])
                                
                                detections.append({
                                    'class': predicted_class,
                                    'confidence': conf,
                                    'bbox': [x1, y1, x2, y2]
                                })
                    
                    # ÁµêÊûúË®òÈå≤
                    is_correct = any(d['class'] == expected_class for d in detections)
                    
                    test_results.append({
                        'image': img_path.name,
                        'expected_class': expected_class,
                        'original_type': lesion_type,
                        'detections': detections,
                        'detection_count': len(detections),
                        'correct': is_correct
                    })
                    
                    print(f"  üì∏ {img_path.name}: {len(detections)}ÂÄãÊ§úÂá∫, Ê≠£Ëß£: {'‚úÖ' if is_correct else '‚ùå'}")
                    
                except Exception as e:
                    print(f"‚ùå „ÉÜ„Çπ„Éà„Ç®„É©„Éº {img_path}: {e}")
        
        # Áµ±Ë®àË®àÁÆó
        total_tests = len(test_results)
        correct_tests = sum(1 for r in test_results if r['correct'])
        accuracy = correct_tests / total_tests if total_tests > 0 else 0
        
        print(f"\\nüìä Stage 3„ÉÜ„Çπ„ÉàÁµêÊûú:")
        print(f"  Á∑è„ÉÜ„Çπ„ÉàÊï∞: {total_tests}")
        print(f"  Ê≠£Ëß£Êï∞: {correct_tests}")
        print(f"  Á≤æÂ∫¶: {accuracy:.3f} ({accuracy*100:.1f}%)")
        
        # ÁµêÊûú‰øùÂ≠ò
        results_path = self.output_dir / "stage3_test_results.json"
        with open(results_path, 'w', encoding='utf-8') as f:
            json.dump({
                'timestamp': datetime.now().isoformat(),
                'model_path': str(enhanced_model_path),
                'accuracy': accuracy,
                'total_tests': total_tests,
                'correct_tests': correct_tests,
                'detailed_results': test_results
            }, f, ensure_ascii=False, indent=2)
        
        return accuracy, test_results
    
    def run_progressive_training(self, source_dir="organized_advanced_masked"):
        """
        ÊÆµÈöéÁöÑÂ≠¶Áøí„Éó„É≠„Çª„ÇπÂÖ®‰Ωì„ÇíÂÆüË°å
        """
        print("üéØ Progressive Lesion Detection Training ÈñãÂßã")
        print("=" * 80)
        print("üìã Â≠¶Áøí„Éó„É©„É≥:")
        print("  Stage 1: PAD-UFES-20Âü∫Á§éÂ≠¶Áøí")
        print("  Stage 2: „Éû„Çπ„ÇØÊ∏à„ÅøÁîªÂÉè„Åß„ÅÆÁóÖÂ§âÊäΩÂá∫Â≠¶Áøí")
        print("  Stage 3: ÂàùË¶ãÁîªÂÉè„Åß„ÅÆÊ§úÂá∫„ÉÜ„Çπ„Éà")
        print("=" * 80)
        
        try:
            # Stage 1: Âü∫Á§é„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàê„Å®Ë®ìÁ∑¥
            stage1_yaml, stage1_count = self.stage1_create_foundation_dataset(source_dir)
            foundation_model, stage1_results = self.stage1_train_foundation_model(stage1_yaml)
            
            # Stage 2: ÁóÖÂ§âÊäΩÂá∫„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàê„Å®Âº∑ÂåñË®ìÁ∑¥
            stage2_yaml, stage2_count = self.stage2_create_masked_lesion_dataset(
                source_dir, foundation_model
            )
            
            if stage2_yaml is None:
                print("‚ùå Stage 2„Åß„Éá„Éº„Çø„Åå‰ΩúÊàê„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü")
                return None
            
            enhanced_model, stage2_results = self.stage2_enhance_model(
                foundation_model, stage2_yaml
            )
            
            # Stage 3: ÂàùË¶ãÁîªÂÉè„ÉÜ„Çπ„Éà
            final_accuracy, test_results = self.stage3_test_on_unseen_images(
                enhanced_model, source_dir
            )
            
            print("\\nüéâ Progressive Training ÂÆå‰∫Ü!")
            print("=" * 80)
            print(f"üìä ÊúÄÁµÇÁµêÊûú:")
            print(f"  Stage 1„Éá„Éº„ÇøÊï∞: {stage1_count}")
            print(f"  Stage 2„Éá„Éº„ÇøÊï∞: {stage2_count}")
            print(f"  ÊúÄÁµÇÁ≤æÂ∫¶: {final_accuracy:.3f} ({final_accuracy*100:.1f}%)")
            print(f"üèÜ ÊúÄÁµÇ„É¢„Éá„É´: {enhanced_model}")
            print("=" * 80)
            
            return {
                'foundation_model': foundation_model,
                'enhanced_model': enhanced_model,
                'final_accuracy': final_accuracy,
                'stage1_count': stage1_count,
                'stage2_count': stage2_count,
                'test_results': test_results
            }
            
        except Exception as e:
            print(f"‚ùå Progressive Training „Ç®„É©„Éº: {e}")
            return None

def main():
    """„É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞"""
    trainer = ProgressiveLesionTrainer()
    results = trainer.run_progressive_training()
    
    if results:
        print(f"\\n‚úÖ ÊÆµÈöéÁöÑÂ≠¶ÁøíÊàêÂäü!")
        print(f"üìà ÈÅîÊàêÁ≤æÂ∫¶: {results['final_accuracy']:.3f}")
        print(f"üéØ ÂàùË¶ãÁîªÂÉè„Åß„ÅÆÁóÖÂ§âËá™ÂãïÊ§úÂá∫„ÅåÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ")
    else:
        print("‚ùå ÊÆµÈöéÁöÑÂ≠¶Áøí„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")

if __name__ == "__main__":
    main()